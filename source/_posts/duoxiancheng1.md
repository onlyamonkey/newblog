## 多线程的实现原理

并发编程中分析线程安全问题需要找到切入点,就是**二大核心**:和**三大性质**就是JMM抽象内存模型以及happens-before规则、三大性质分别是原子性、可见性、有序性。

### 二大核心

#### 内存模型(JMM)

##### 内存模型抽象结构

​     线程安全问题一般都是因为主内存和工作内存的数据不一致性和重排序导致的,解决线程安全问题的关键在于理解JMM内存模型。并发编程中主要解决两个问题:**1.线程之间如何通信**、**2.线程之间如何同步**通信是指线程之间以何种方式来交换信息,主要有两种:**共享内存**和**消息传递** 。

###### 哪些是共享变量

 实例域、静态域、数组单元都存放在堆里面的,所有线程都可以访问的。        

###### JMM抽象结构模型

​       我们知道CPU的处理速度和主存的读写速度不是一个量级的,为了平衡这种巨大的差距，每个CPU都会有缓存。因此，共享变量会先放在主存中，每个线程都有属于自己的工作内存，并且会把位于主存中的共享变量拷贝到自己的工作内存，之后的读写操作均使用位于工作内存的变量副本，并在某个时刻将工作内存的变量副本写回到主存中去。JMM就从抽象层次定义了这种方式，并且JMM决定了一个线程对共享变量的写入何时对其他线程是可见的。

![004](images\004.png)

如图为JMM抽象示意图，线程A和线程B之间要完成通信的话，要经历如下两步：

1. 线程A从主内存中将共享变量读入线程A的工作内存后并进行操作，之后将数据重新写回到主内存中；
2. 线程B从主存中读取最新的共享变量

从横向去看看，线程A和线程B就好像通过共享变量在进行隐式通信。这其中有很有意思的问题，如果线程A更新后数据并没有及时写回到主存，而此时线程B读到的是过期的数据，这就出现了“脏读”现象。可以通过同步机制（控制不同线程间操作发生的相对顺序）来解决或者通过volatile关键字使得每次volatile变量都能够强制刷新到主存，从而对每个线程都是可见的。

##### 重排序

​    目的:在不改变程序执行结果的前提下，尽可能提高并行度。在执行程序时,为了提高性能,编译器和处理器会对指令进行重排序。重排序可以分为三种情况:

![004](images\005.png)

1.编译器优化的重排序。编译器在不改变单线程程序语义的前提下,可以重新安排语句的执行顺序；

2.指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果**不存在数据依赖性**,处理器可以改变语句对应机器指令的执行顺序；

3.内存系统的重排序。由于处理器使用缓存和读/写缓冲区,这使得加载和存储操作看上去可能是在乱序执行的。

如图,1属于编译器重排序，而2和3统称为处理器重排序。这些重排序会导致线程安全的问题，一个很经典的例子就是DCL问题,**针对编译器重排序**，JMM的编译器重排序规则会禁止一些**特定类型的编译器重排序**；**针对处理器重排序**，编译器在生成指令序列的时候会通过**插入内存屏障指令来禁止某些特殊的处理器重排序**。

##### 不进行重排序的情况(存在数据依赖性)

那么什么情况下,不能进行重排序了？下面就来说说数据依赖性。有如下代码:

```java
double pi = 3.14 //A

double r = 2.0 //B

double area = pi * r * r //C
```

这是一个计算圆面积的代码，由于A,B之间没有任何关系，对最终结果也不会存在关系，它们之间执行顺序可以重排序。因此可以执行顺序可以是A->B->C或者B->A->C执行最终结果都是3.14，即A和B之间没有数据依赖性。具体的定义为:**如果两个操作访问同一个变量,且这两个操作有一个为写操作，此时这两个操作就存在数据依赖性**这里就存在三种情况：1. 读后写；2.写后写；3. 写后读,这三种操作都是存在数据依赖性的，如果重排序会对最终执行结果会存在影响。**编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序**。

##### as-if-serial

 不管怎么重排序(编译器和处理器为了提供并行度),(单线程)程序的执行结果不能被改变。单线程情况下,如果程序不存在依赖性也可能会进行指令重排序。

#### happens-before(之前发生)

​      从JDK5开始，提出了happens-before的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。**JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证**(如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行,但JMM向程序员保证a操作将对b操作可见)

具体定义如下:

​     1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。

​    2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致,那么这种重排序并不非法（也就是说，JMM允许这种重排序）。

上面的**1）是JMM对程序员的承诺**。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。注意,这只是Java内存模型向程序员做出的保证！

上面的**2）是JMM对编译器和处理器重排序的约束原则**。正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。

##### as-if-serial vs happens-before

  1.as-if-serial语义保证单线程内程序的执行结果不被改变,happens-before关系保证正确同步的多线程程序的执行结果不被改变。

2.as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。

3.as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。

##### 具体的六项规则

1.程序顺序规则:一个线程内,按照代码顺序，书写在前面的操作先行发生于书写在后面的操作;

2.监视器锁规则:一个unLock操作先行发生于后面对同一个锁额lock操作；

3.volatile变量规则:对一个变量的写操作先行发生于后面对这个变量的读操作；

4.传递性:如果操作A先行发生于操作B,而操作B又先行发生于操作C,则可以得出操作A先行发生于操作C；

5.start()规则:Thread对象的start()方法先行发生于此线程的每个一个动作；

6.join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。

7.程序中断规则:对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。

8.对象finalize规则:一个对象的初始化完成先行发生于他的finalize()方法的开始；

下面以一个**具体的例子来讲下如何使用这些规则进行推论**：

依旧以上面计算圆面积的进行描述。利用程序顺序规则（规则1）存在三个happens-before关系：1. A happens-before B；2. B happens-before C;3. A happens-before C。这里的第三个关系是利用传递性进行推论的。A happens-before B,定义1要求A执行结果对B可见，并且A操作的执行顺序在B操作之前，但与此同时利用定义中的第二条，A,B操作彼此不存在数据依赖性，两个操作的执行顺序对最终结果都不会产生影响，在不改变最终结果的前提下，允许A，B两个操作重排序，即happens-before关系并不代表了最终的执行顺序。

### 三大性质

     ####    原子性

​     原子性是指一个操作是不可中断的,要么全部执行成功,要么全部执行失败,有种**同生共死**的感觉。在JVM中有两个指令monitorenter和monitorexit,在JAVA中对应的就是**synchronized**满足原子性。

####    可见性

  可见性是指当一个线程修改了共享变量后,其他线程能够立即得到这个修改。**synchronized****(当线程获取锁时会从主内存中获取共享变量的最新值,释放锁的时候会将共享变量同步到主内中)**volatile**(volidate对变量进行操作时,会写入一个lock前缀的汇编指令,这个指令会触发总线锁或者缓存锁,然后通过MESI协议的缓存一致性协议来保证数据的一致性)和**final**这三个都具有可见性。

####    有序性

​        在java中**synchronized**和**volidate**都可以保证多线程操作的有序性。两者的区别是:volidate关键字会禁止执行重排序。synchronized关键字是同一时刻只允许一条线程操作。